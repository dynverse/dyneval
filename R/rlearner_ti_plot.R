#' Perform dimensionality reduction on a trajectory and the respective samples in order to plot it
#'
#' @param traj_object A trajectory as generated by \link{\code{wrap_ti_task_data}} or
#'  \link{\code{wrap_ti_prediction}}
#' @param insert_phantom_edges attempt to plot bifurcating edges correctly automatically
#'
#' @import dplyr
#' @importFrom igraph graph_from_data_frame layout_with_kk E
#' @importFrom SCORPIUS rescale.and.center
#' @importFrom RColorBrewer brewer.pal
#'
#' @export
plotdata_default <- function(traj_object, insert_phantom_edges = T) {
  name <- paste0(traj_object$type, "/", traj_object$ti_type, "/", traj_object$name)

  # retrieve information on milestones
  milestone_ids <- traj_object$milestone_ids
  if (length(milestone_ids) <= 12) {
    colour_milestones <- RColorBrewer::brewer.pal(max(3, length(milestone_ids)), "Set3")[seq_along(milestone_ids)]
    colours_milestones <- setNames(colour_milestones, milestone_ids)
  } else {
    colours_milestones <- setNames(sample(rainbow(length(milestone_ids))), milestone_ids)
  }
  colours_rgb_milestones <- t(col2rgb(colours_milestones))

  # get milestone_network
  milestone_network <- traj_object$milestone_network

  # retrieve information on samples
  milestone_percentages <- traj_object$milestone_percentages %>% spread(milestone, percentage)
  milestone_percentages_m <- as.matrix(milestone_percentages[,milestone_ids,drop=F])
  rownames(milestone_percentages_m) <- milestone_percentages$id
  colours_rgb_samples <- milestone_percentages_m %*% colours_rgb_milestones
  colours_samples <- mapply(colours_rgb_samples[,1], colours_rgb_samples[,2], colours_rgb_samples[,3], FUN = rgb, maxColorValue = 256)

  # add imaginary links, ifneedbe
  if (insert_phantom_edges) {
    structure <- bind_rows(
      milestone_network,
      bind_rows(lapply(milestone_ids, function(x) {
        strx <- milestone_network %>%
          filter(from == x)

        if (nrow(strx) > 1) {
          strx <- strx %>%
            mutate(
              angle = seq(0, 120/360*pi*2, length.out = n()),
              x = length * cos(angle),
              y = length * sin(angle)
            )
          poss <- strx %>% select(x, y) %>% as.matrix
          rownames(poss) <- strx$to
          poss %>%
            dist %>%
            as.matrix %>%
            reshape2::melt(varnames = c("from", "to"), value.name = "length") %>%
            mutate(from = as.character(from), to = as.character(to)) %>%
            filter(from != to)
        } else {
          NULL
        }
      })),
      bind_rows(lapply(milestone_ids, function(x) {
        strx <- milestone_network %>%
          filter(to == x)

        if (nrow(strx) > 1) {
          strx <- strx %>%
            mutate(
              angle = seq(0, 120/360*pi*2, length.out = n()),
              x = length * cos(angle),
              y = length * sin(angle)
            )
          poss <- strx %>% select(x, y) %>% as.matrix
          rownames(poss) <- strx$from
          poss %>%
            dist %>%
            as.matrix %>%
            reshape2::melt(varnames = c("from", "to"), value.name = "length") %>%
            mutate(from = as.character(from), to = as.character(to)) %>%
            filter(from != to)
        } else {
          NULL
        }
      })))
  } else {
    structure <- milestone_network
  }

  # reduce dimensionality on milestone_network
  gr <- graph_from_data_frame(structure, vertices = milestone_ids)
  lengths <- E(gr)$length
  if (min(lengths) * 3 < max(lengths)) {
    lengths <- ((lengths - min(lengths)) / (max(lengths) - min(lengths)) + .5) %>% sqrt
  }

  gr_space_milestones <- layout_with_kk(gr, weights = lengths, maxiter = 200) %>% SCORPIUS::rescale.and.center()
  dimnames(gr_space_milestones) <- list(milestone_ids, paste0("Comp", seq_len(ncol(gr_space_milestones))))

  # project dimensionality to samples
  gr_space_samples <- milestone_percentages_m %*% gr_space_milestones

  # format data
  space_milestones <- data.frame(
    name,
    id = milestone_ids,
    gr_space_milestones,
    colour = colours_milestones,
    stringsAsFactors = F)
  space_lines <- data.frame(
    name,
    from = gr_space_milestones[milestone_network$from,,drop=F],
    to = gr_space_milestones[milestone_network$to,,drop=F],
    row.names = NULL,
    stringsAsFactors = F)
  space_samples <- data.frame(
    name,
    id = milestone_percentages$id,
    gr_space_samples,
    colour = colours_samples,
    stringsAsFactors = F)

  l <- list(
    space_milestones = space_milestones,
    space_lines = space_lines,
    space_samples = space_samples
  )
  class(l) <- "dyneval::ti_dimred_wrapper"
  l
}

is_ti_dimred_wrapper <- function(object) {
  class(object) == "dyneval::ti_dimred_wrapper"
}

#' Plot a dimensionality reduced trajectory
#'
#' @param object output as generated by \code{plotLearnerData.ti.default}, \link{\code{wrap_ti_task_data}} or \link{\code{wrap_ti_prediction}}
#' @param insert_phantom_edges attempt to plot bifurcating edges correctly automatically
#'
#' @import ggplot2
#' @importFrom grid arrow
#'
#' @export
plot_default <- function(object, insert_phantom_edges = T) {
  if (is_ti_wrapper(object)) {
    dimred_object <- plotdata_default(object, insert_phantom_edges = insert_phantom_edges)
  } else if (is_ti_dimred_wrapper(object)) {
    dimred_object <- object
  } else {
    stop(sQuote("object"), " is not an object as generated by plotLearnerData.ti.default, wrap_ti_task_data or wrap_ti_prediction.")
  }
  with(dimred_object, {
    ggplot() +
      geom_segment(aes(x = from.Comp1, xend = to.Comp1, y = from.Comp2, yend = to.Comp2), space_lines,
                   size = 10, colour = "#444444", arrow = arrow(length = unit(.5, "cm"), type="closed")) +
      geom_point(aes(Comp1, Comp2, colour = colour), space_samples, size = 3) +
      geom_point(aes(Comp1, Comp2, colour = colour, fill = colour), space_milestones, size = 5, shape = 4, stroke = 2) +
      geom_text(aes(Comp1, Comp2, label = id), space_milestones, nudge_y = .05) +
      scale_colour_identity() +
      scale_fill_identity() +
      scale_x_continuous(limits = c(-.55, .55)) +
      scale_y_continuous(limits = c(-.55, .55)) +
      coord_equal() +
      labs(x = "Component 1", y = "Component 2")
  })
}

#' Plot a dimensionality reduced trajectory
#'
#' @param original_object output as generated by \code{plotLearnerData.ti.default}, \link{\code{wrap_ti_task_data}} or \link{\code{wrap_ti_prediction}}
#' @param new_object output as generated by \code{plotLearnerData.ti.default}, \link{\code{wrap_ti_task_data}} or \link{\code{wrap_ti_prediction}}
#' @param insert_phantom_edges attempt to plot bifurcating edges correctly automatically
#'
#' @import ggplot2
#' @importFrom grid arrow
#'
#' @export
plot_combined <- function(original_object, new_object, insert_phantom_edges = T) {
  if (is_ti_wrapper(original_object)) {
    original_dimred <- plotdata_default(original_object, insert_phantom_edges = insert_phantom_edges)
  } else if (is_ti_dimred_wrapper(original_object)) {
    original_dimred <- original_object
  } else {
    stop(sQuote("original_object"), " is not an object as generated by plotLearnerData.ti.default, wrap_ti_task_data or wrap_ti_prediction.")
  }

  if (is_ti_wrapper(new_object)) {
    new_dimred <- plotdata_default(new_object, insert_phantom_edges = insert_phantom_edges)
  } else if (is_ti_dimred_wrapper(new_object)) {
    new_dimred <- new_object
  } else {
    stop(sQuote("new_object"), " is not an object as generated by plotLearnerData.ti.default, wrap_ti_task_data or wrap_ti_prediction.")
  }

  combined_dimred <- new_dimred
  combined_dimred$space_samples$colour <- original_dimred$space_samples$colour

  with(combined_dimred, {
    ggplot() +
      geom_segment(aes(x = from.Comp1, xend = to.Comp1, y = from.Comp2, yend = to.Comp2), space_lines,
                   size = 10, colour = "#444444", arrow = arrow(length = unit(.5, "cm"), type="closed")) +
      geom_point(aes(Comp1, Comp2, colour = colour), space_samples, size = 3, alpha = .5) +
      scale_colour_identity() +
      scale_fill_identity() +
      scale_x_continuous(limits = c(-.55, .55)) +
      scale_y_continuous(limits = c(-.55, .55)) +
      coord_equal() +
      labs(x = "Component 1", y = "Component 2")
  })
}
